###############################################################################
#                                                                             #
#                                                       17/Jan/2011  18:58:45 #
# IAR Atmel AVR C/C++ Compiler V4.30A/W32, Evaluation Version                 #
# Copyright 1996-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Source file  =  D:\current_prj\batt\BATT_emb\coms.c                      #
#    Command line =  D:\current_prj\batt\BATT_emb\coms.c --cpu=m128 -ms -o    #
#                    D:\current_prj\batt\BATT_emb\Debug\Obj\ -lCN             #
#                    D:\current_prj\batt\BATT_emb\Debug\List\ -y              #
#                    --initializers_in_flash -z2 --no_cse --no_inline         #
#                    --no_code_motion --no_cross_call --no_clustering         #
#                    --no_tbaa --debug -DENABLE_BIT_DEFINITIONS -e -I         #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 4.0     #
#                    Evaluation\avr\INC\" -I "C:\Program Files\IAR            #
#                    Systems\Embedded Workbench 4.0                           #
#                    Evaluation\avr\INC\CLIB\" --eeprom_size 4096             #
#    List file    =  D:\current_prj\batt\BATT_emb\Debug\List\coms.lst         #
#    Object file  =  D:\current_prj\batt\BATT_emb\Debug\Obj\coms.r90          #
#                                                                             #
#                                                                             #
###############################################################################

D:\current_prj\batt\BATT_emb\coms.c
      1          //#define uart1_ex
      2          #define ver 1
      3          #define subver 4
      4          
      5          
      6          //определим смещение до адреса и контрольного поля
      7          #define AF 2
      8          #define CF 3
      9          
     10          #define	FCres 0 /* удаленный сброс устройства                   */
     11          #define	FClink 1 /* удаленная переинициализация связи           */
     12          
     13          
     14          #define	FCtest 2/* тест связи                                   */
     15          
     16          #define	FCgetbat 4 /* запрос информации о тек. состоянии батарей */
     17          #define FCsetprofile 0x05  /* запрос информации о тек. состоянии батарей */
     18          #define FCsetactivation 0x06 /* переход в режим активации */
     19          #define FCsetbyprofile 0x07  /* переход в режим работы по профилю */
     20          #define FCresetfrmcnt 0x08  /* сброс счетчика кадров */
     21          #define FCgetitems 0x09  /* получить данные прогона по профилю */
     22          #define FCcalibr 0x0a  /* инициация калибровки */
     23          
     24          //#define	FCgetind 0x1b 
     25          
     26          
     27          
     28          #define	FCexept  15/*- exception на функцию                     */
     29          
     30          #define	ex_no_support  1/*- запрашиваемая функция не поддерживается  */
     31          
     32          
     33          
     34          
     35          
     36          #include <iom128.h>

   \                                 In  segment ABSOLUTE, at 0x29
   \   <unnamed> volatile __io _A_UBRR0L
   \                     _A_UBRR0L:
   \   00000000                      DS 1

   \                                 In  segment ABSOLUTE, at 0x2a
   \   <unnamed> volatile __io _A_UCSR0B
   \                     _A_UCSR0B:
   \   00000000                      DS 1

   \                                 In  segment ABSOLUTE, at 0x2b
   \   <unnamed> volatile __io _A_UCSR0A
   \                     _A_UCSR0A:
   \   00000000                      DS 1

   \                                 In  segment ABSOLUTE, at 0x2c
   \   <unnamed> volatile __io _A_UDR0
   \                     _A_UDR0:
   \   00000000                      DS 1

   \                                 In  segment ABSOLUTE, at 0x3c
   \   <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS 1

   \                                 In  segment ABSOLUTE, at 0x3d
   \   <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS 1

   \                                 In  segment ABSOLUTE, at 0x3e
   \   <unnamed> volatile __io _A_EEAR
   \                     _A_EEAR:
   \   00000000                      DS 2

   \                                 In  segment ABSOLUTE, at 0x4a
   \   <unnamed> volatile __io _A_OCR1A
   \                     _A_OCR1A:
   \   00000000                      DS 2

   \                                 In  segment ABSOLUTE, at 0x4c
   \   <unnamed> volatile __io _A_TCNT1
   \                     _A_TCNT1:
   \   00000000                      DS 2

   \                                 In  segment ABSOLUTE, at 0x56
   \   <unnamed> volatile __io _A_TIFR
   \                     _A_TIFR:
   \   00000000                      DS 1

   \                                 In  segment ABSOLUTE, at 0x90
   \   <unnamed> volatile __io _A_UBRR0H
   \                     _A_UBRR0H:
   \   00000000                      DS 1

   \                                 In  segment ABSOLUTE, at 0x95
   \   <unnamed> volatile __io _A_UCSR0C
   \                     _A_UCSR0C:
   \   00000000                      DS 1

   \                                 In  segment ABSOLUTE, at 0x9a
   \   <unnamed> volatile __io _A_UCSR1B
   \                     _A_UCSR1B:
   \   00000000                      DS 1
     37          #include "ina90.h"
     38          //#include "led.h"
     39          #include "types.h"
     40          #include "hwr.h"
     41          #include "byte_stuff.h"
     42          #include "coms.h"
     43          #include "hist.h"
     44          #include "adc.h"
     45          #include "timeservice.h"
     46          #include "func_handle.h"
     47          //#include "extRAM\RAMtest.h"
     48          //#include "ADCm\adc.h"
     49          extern thist hist;
     50          extern int curoffset;

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     51          char frmcnt; //номер последнего отправленного кадра
   \                     frmcnt:
   \   00000000                      DS 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     52          char * forsend;//указатель на буфер для передачи;
   \                     forsend:
   \   00000000                      DS 2

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     53          char work_mode=0;//режим работы 0- режим активации
   \                     work_mode:
   \   00000000                      DS 1
     54                                  //       1- одна из батарей завершила активацию, ток снят.
     55                                   //      10 - режим прогона по профилю
     56          
     57          extern UINT getcrc(UCHAR *puchMsg, UINT usDataLen);

   \                                 In  segment NEAR_I, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_I>`
     58          char adr=2; //это адрес платы коммутации
   \                     adr:
   \   00000000                      DS 1
   \   00000001                      REQUIRE `?<Initializer for adr>`
     59          

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     60          trecctx rec0ctx;
   \                     rec0ctx:
   \   00000000                      DS 515
     61          #ifdef uart1_ex   
     62          trecctx  rec1ctx;
     63          #endif
     64          void setcur(char i);

   \                                 In  segment CODE, align 2, keep-with-next
     65          void iniuart0(unsigned int speed,char par){
   \                     iniuart0:
   \   00000000   ........           CALL    ?PROLOGUE4_L09
   \   00000004   01D8               MOVW    R27:R26, R17:R16
   \   00000006   2F82               MOV     R24, R18
     66          _ID
   \   00000008   94F8               CLI
     67          
     68          //DDRE_Bit2=1; //установили бит управления передатчиком на вывод
     69          txen0ini
     70          SEND0OFF;
     71           UCSR0A=2; //установили бит  U2X
   \   0000000A   E002               LDI     R16, 2
   \   0000000C   B90B               OUT     0x0B, R16
     72           UCSR0B = (1<<RXEN0)|(1<<TXEN0);
   \   0000000E   E108               LDI     R16, 24
   \   00000010   B90A               OUT     0x0A, R16
     73           UCSR0C=((1<<1)|(1<<2));//УСТАНОВИЛИ 8БИТ ДАННЫХ И 1 СТОП
   \   00000012   E006               LDI     R16, 6
   \   00000014   93000095           STS     149, R16
     74           switch (par){
   \   00000018   2F08               MOV     R16, R24
   \   0000001A   5000               SUBI    R16, 0
   \   0000001C   F029               BREQ    ??iniuart0_0
   \   0000001E   950A               DEC     R16
   \   00000020   F0A1               BREQ    ??iniuart0_1
   \   00000022   950A               DEC     R16
   \   00000024   F039               BREQ    ??iniuart0_2
   \   00000026   C01B               RJMP    ??iniuart0_3
     75             case none:{ 
     76               UCSR0C&=~((1<<UPM01)|(1<<UPM00));
   \                     ??iniuart0_0:
   \   00000028   91000095           LDS     R16, 149
   \   0000002C   7C0F               ANDI    R16, 0xCF
   \   0000002E   93000095           STS     149, R16
     77               break;
   \   00000032   C015               RJMP    ??iniuart0_3
     78             };  
     79             case even:{ 
     80               UCSR0C|= 1<<UPM01;
   \                     ??iniuart0_2:
   \   00000034   91000095           LDS     R16, 149
   \   00000038   6200               ORI     R16, 0x20
   \   0000003A   93000095           STS     149, R16
     81               UCSR0C&=~(1<<UPM10);
   \   0000003E   91000095           LDS     R16, 149
   \   00000042   7E0F               ANDI    R16, 0xEF
   \   00000044   93000095           STS     149, R16
     82               break;
   \   00000048   C00A               RJMP    ??iniuart0_3
     83             };  
     84             case odd:{ 
     85               UCSR0C|= 1<<UPM01;
   \                     ??iniuart0_1:
   \   0000004A   91000095           LDS     R16, 149
   \   0000004E   6200               ORI     R16, 0x20
   \   00000050   93000095           STS     149, R16
     86               UCSR0C|=1<<UPM00;
   \   00000054   91000095           LDS     R16, 149
   \   00000058   6100               ORI     R16, 0x10
   \   0000005A   93000095           STS     149, R16
     87               break;
     88             };  
     89           };
     90          /* регистр tccr0
     91           7 =1 - не нужен PWM
     92           6,3 = zero - обычная мода
     93           5,4 =zero - не используется выход модуляции
     94           2,1,zero - предделитель
     95          */
     96            switch (speed){
   \                     ??iniuart0_3:
   \   0000005E   018D               MOVW    R17:R16, R27:R26
   \   00000060   ....               LDI     R30, LOW(`?<Jumptable for iniuart0>_0`)
   \   00000062   ....               LDI     R31, (`?<Jumptable for iniuart0>_0`) >> 16
   \   00000064   BFFB               OUT     0x3B, R31
   \   00000066   ....               LDI     R31, HIGH(`?<Jumptable for iniuart0>_0`)
   \   00000068   ........           JMP     ?SV_SWITCH_L06
     97              case 48:{
     98          //      TCCR0CH=CTC124_0;// CTC мода предделитель 1024;
     99                UBRR0L=383-256; 
   \                     ??iniuart0_4:
   \   0000006C   E70F               LDI     R16, 127
   \   0000006E   B909               OUT     0x09, R16
    100                UBRR0H = (unsigned char)(383>>8);
   \   00000070   E001               LDI     R16, 1
   \   00000072   93000090           STS     144, R16
    101                UBRR0L = (unsigned char)383;
   \   00000076   E70F               LDI     R16, 127
   \   00000078   B909               OUT     0x09, R16
    102                break;
   \   0000007A   C023               RJMP    ??iniuart0_5
    103              }case 96:{
    104          //      TCCR0CH=CTC124_0; // CTC мода предделитель 1024;
    105                UBRR0H = 0;
   \                     ??iniuart0_6:
   \   0000007C   E000               LDI     R16, 0
   \   0000007E   93000090           STS     144, R16
    106                UBRR0L = 191;
   \   00000082   EB0F               LDI     R16, 191
   \   00000084   B909               OUT     0x09, R16
    107                break;
   \   00000086   C01D               RJMP    ??iniuart0_5
    108              }case 192:{
    109          //      TCCR0CH=CTC256_0; // CTC мода предделитель 256;
    110                UBRR0H = 0;
   \                     ??iniuart0_7:
   \   00000088   E000               LDI     R16, 0
   \   0000008A   93000090           STS     144, R16
    111                UBRR0L = 95;
   \   0000008E   E50F               LDI     R16, 95
   \   00000090   B909               OUT     0x09, R16
    112                break;
   \   00000092   C017               RJMP    ??iniuart0_5
    113              }case 384:{
    114          //      TCCR0CH=CTC256_0;
    115                UBRR0H = 0;
   \                     ??iniuart0_8:
   \   00000094   E000               LDI     R16, 0
   \   00000096   93000090           STS     144, R16
    116                UBRR0L = 47;    
   \   0000009A   E20F               LDI     R16, 47
   \   0000009C   B909               OUT     0x09, R16
    117                break;
   \   0000009E   C011               RJMP    ??iniuart0_5
    118              }
    119              case 576: {
    120          //      TCCR0CH=CTC256_0; 
    121                UBRR0H = 0;
   \                     ??iniuart0_9:
   \   000000A0   E000               LDI     R16, 0
   \   000000A2   93000090           STS     144, R16
    122                UBRR0L = 31;
   \   000000A6   E10F               LDI     R16, 31
   \   000000A8   B909               OUT     0x09, R16
    123                break;
   \   000000AA   C00B               RJMP    ??iniuart0_5
    124              }
    125              case 1152: {
    126          //      TCCR0CH=CTC256_0; 
    127                UBRR0H = 0;
   \                     ??iniuart0_10:
   \   000000AC   E000               LDI     R16, 0
   \   000000AE   93000090           STS     144, R16
    128                UBRR0L = 15;
   \   000000B2   E00F               LDI     R16, 15
   \   000000B4   B909               OUT     0x09, R16
    129                break;
   \   000000B6   C005               RJMP    ??iniuart0_5
    130              }
    131              default: { //57600
    132          //      TCCR0CH=CTC256_0; 
    133                UBRR0H = 0;
   \                     ??iniuart0_11:
   \   000000B8   E000               LDI     R16, 0
   \   000000BA   93000090           STS     144, R16
    134                UBRR0L = 31;
   \   000000BE   E10F               LDI     R16, 31
   \   000000C0   B909               OUT     0x09, R16
    135                break;
    136             };                 
    137            };
    138          
    139          //  TCNT0CH=0;
    140          //  OCIE0CH=1;//разрешили прерывание от таймера  по COMP !!!!!!
    141            inirec(&rec0ctx);
   \                     ??iniuart0_5:
   \   000000C2   ....               LDI     R16, LOW(rec0ctx)
   \   000000C4   ....               LDI     R17, (rec0ctx) >> 8
   \   000000C6   ........           CALL    inirec
    142          //  redon2
    143            UCSR0B|=(1<<RXCIE0); //разрешили прерывания от приемника
   \   000000CA   9A57               SBI     0x0A, 0x07
    144          _IE  
   \   000000CC   9478               SEI
    145          };
   \   000000CE   E0E4               LDI     R30, 4
   \   000000D0   ........           JMP     ?EPILOGUE_B4_L09
   \   000000D4                      REQUIRE _A_UBRR0L
   \   000000D4                      REQUIRE _A_UCSR0B
   \   000000D4                      REQUIRE _A_UCSR0A
   \   000000D4                      REQUIRE _A_UBRR0H
   \   000000D4                      REQUIRE _A_UCSR0C
    146          #ifdef uart1_ex   
    147          void iniuart1(unsigned int speed,char par){
    148          _ID
    149          
    150          //DDRE_Bit2=1; //установили бит управления передатчиком на вывод
    151          txen1ini
    152          SEND1OFF;
    153           UCSR1A=2; //установили бит  U2X
    154           UCSR1B = (1<<RXEN1)|(1<<TXEN1);
    155           UCSR1C=((1<<1)|(1<<2));//УСТАНОВИЛИ 8БИТ ДАННЫХ И 1 СТОП
    156           switch (par){
    157             case none:{ 
    158               UCSR1C&=~((1<<UPM11)|(1<<UPM10));
    159               break;
    160             };  
    161             case even:{ 
    162               UCSR1C|= 1<<UPM11;
    163               UCSR1C&=~(1<<UPM10);
    164               break;
    165             };  
    166             case odd:{ 
    167               UCSR1C|= 1<<UPM11;
    168               UCSR1C|=1<<UPM10;
    169               break;
    170             };  
    171           };
    172          /* регистр tccr0
    173           7 =1 - не нужен PWM
    174           6,3 = zero - обычная мода
    175           5,4 =zero - не используется выход модуляции
    176           2,1,zero - предделитель
    177          */
    178            switch (speed){
    179              case 48:{
    180          //      TCCR0CH=CTC124_0;// CTC мода предделитель 1024;
    181                UBRR1L=383-256; 
    182                UBRR1H = (unsigned char)(383>>8);
    183                UBRR1L = (unsigned char)383;
    184                break;
    185              }case 96:{
    186          //      TCCR1CH=CTC124_0; // CTC мода предделитель 1024;
    187                UBRR1H = 0;
    188                UBRR1L = 191;
    189                break;
    190              }case 192:{
    191          //      TCCR1CH=CTC256_0; // CTC мода предделитель 256;
    192                UBRR1H = 0;
    193                UBRR1L = 95;
    194                break;
    195              }case 384:{
    196          //      TCCR1CH=CTC256_0;
    197                UBRR1H = 0;
    198                UBRR1L = 47;    
    199                break;
    200              }
    201              case 576: {
    202          //      TCCR1CH=CTC256_0; 
    203                UBRR1H = 0;
    204                UBRR1L = 31;
    205                break;
    206              }
    207              case 1152: {
    208          //      TCCR1CH=CTC256_0; 
    209                UBRR1H = 0;
    210                UBRR1L = 15;
    211                break;
    212              }
    213              default: { //57600
    214          //      TCCR1CH=CTC256_0; 
    215                UBRR1H = 0;
    216                UBRR1L = 31;
    217                break;
    218             };                 
    219            };
    220            inirec(&rec1ctx);
    221            UCSR1B|=(1<<RXCIE1); //разрешили прерывания от приемника
    222            _IE  
    223          };
    224          #endif //uart1
    225          //trecctx rec0ctx,rec1ctx;
    226          #pragma vector=USART0_TXC_vect

   \                                 In  segment CODE, align 2, keep-with-next
    227          __interrupt void tx0end_isr() {
   \                     tx0end_isr:
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   93FA               ST      -Y, R31
   \   00000006   93EA               ST      -Y, R30
   \   00000008   923A               ST      -Y, R3
   \   0000000A   922A               ST      -Y, R2
   \   0000000C   921A               ST      -Y, R1
   \   0000000E   920A               ST      -Y, R0
   \   00000010   937A               ST      -Y, R23
   \   00000012   936A               ST      -Y, R22
   \   00000014   935A               ST      -Y, R21
   \   00000016   934A               ST      -Y, R20
   \   00000018   933A               ST      -Y, R19
   \   0000001A   932A               ST      -Y, R18
   \   0000001C   931A               ST      -Y, R17
   \   0000001E   930A               ST      -Y, R16
   \   00000020   B78F               IN      R24, 0x3F
   \   00000022   B79B               IN      R25, 0x3B
    228          
    229          //      red3^=1;
    230                UCSR0B|=(1<<RXCIE0);//разрешаем прерывания от приемника
   \   00000024   9A57               SBI     0x0A, 0x07
    231                UCSR1B|=(1<<RXCIE1);//разрешаем прерывания от приемника
   \   00000026   9100009A           LDS     R16, 154
   \   0000002A   6800               ORI     R16, 0x80
   \   0000002C   9300009A           STS     154, R16
    232                UCSR0B&=~(1<<TXCIE0); //запрещаем  прерывания на завершение выталкивания посл. байта
   \   00000030   9856               CBI     0x0A, 0x06
    233                EI
   \   00000032   9478               SEI
    234          //      UCSR0B|=(1<<RXCIE0);//разрешаем прерывания от приемника
    235                SEND0OFF
    236                inirec(&rec0ctx);
   \   00000034   ....               LDI     R16, LOW(rec0ctx)
   \   00000036   ....               LDI     R17, (rec0ctx) >> 8
   \   00000038   ........           CALL    inirec
    237          }
   \   0000003C   BF9B               OUT     0x3B, R25
   \   0000003E   BF8F               OUT     0x3F, R24
   \   00000040   9109               LD      R16, Y+
   \   00000042   9119               LD      R17, Y+
   \   00000044   9129               LD      R18, Y+
   \   00000046   9139               LD      R19, Y+
   \   00000048   9149               LD      R20, Y+
   \   0000004A   9159               LD      R21, Y+
   \   0000004C   9169               LD      R22, Y+
   \   0000004E   9179               LD      R23, Y+
   \   00000050   9009               LD      R0, Y+
   \   00000052   9019               LD      R1, Y+
   \   00000054   9029               LD      R2, Y+
   \   00000056   9039               LD      R3, Y+
   \   00000058   91E9               LD      R30, Y+
   \   0000005A   91F9               LD      R31, Y+
   \   0000005C   9189               LD      R24, Y+
   \   0000005E   9199               LD      R25, Y+
   \   00000060   9518               RETI
   \   00000062                      REQUIRE _A_UCSR0B
   \   00000062                      REQUIRE _A_UCSR1B
    238          #pragma vector=USART0_RXC_vect

   \                                 In  segment CODE, align 2, keep-with-next
    239          __interrupt void rx0_isr() {
   \                     rx0_isr:
   \   00000000   93AA               ST      -Y, R26
   \   00000002   939A               ST      -Y, R25
   \   00000004   938A               ST      -Y, R24
   \   00000006   93FA               ST      -Y, R31
   \   00000008   93EA               ST      -Y, R30
   \   0000000A   923A               ST      -Y, R3
   \   0000000C   922A               ST      -Y, R2
   \   0000000E   921A               ST      -Y, R1
   \   00000010   920A               ST      -Y, R0
   \   00000012   937A               ST      -Y, R23
   \   00000014   936A               ST      -Y, R22
   \   00000016   935A               ST      -Y, R21
   \   00000018   934A               ST      -Y, R20
   \   0000001A   933A               ST      -Y, R19
   \   0000001C   932A               ST      -Y, R18
   \   0000001E   931A               ST      -Y, R17
   \   00000020   930A               ST      -Y, R16
   \   00000022   B79F               IN      R25, 0x3F
   \   00000024   B7AB               IN      R26, 0x3B
    240          char r;
    241          UCSR0B&=~(1<<RXCIE0);//запрещаем прерывания от приемника
   \   00000026   9857               CBI     0x0A, 0x07
    242              EI
   \   00000028   9478               SEI
    243          
    244          
    245          r=recnextch(UDR0,&rec0ctx);
   \   0000002A   ....               LDI     R18, LOW(rec0ctx)
   \   0000002C   ....               LDI     R19, (rec0ctx) >> 8
   \   0000002E   B10C               IN      R16, 0x0C
   \   00000030   ........           CALL    recnextch
   \   00000034   2F80               MOV     R24, R16
    246          if (r==10) { //начали прием нового кадра
   \   00000036   308A               CPI     R24, 10
   \   00000038   F451               BRNE    ??rx0_isr_0
    247            TCNT1=0; 
   \   0000003A   E000               LDI     R16, 0
   \   0000003C   E010               LDI     R17, 0
   \   0000003E   BD1D               OUT     0x2D, R17
   \   00000040   BD0C               OUT     0x2C, R16
    248            OCR1A = 0xffff;//68
   \   00000042   EF0F               LDI     R16, 255
   \   00000044   EF1F               LDI     R17, 255
   \   00000046   BD1B               OUT     0x2B, R17
   \   00000048   BD0A               OUT     0x2A, R16
    249            TIFR = (1<<OCF1A); //сбросили имевшееся прерывание.
   \   0000004A   E100               LDI     R16, 16
   \   0000004C   BF06               OUT     0x36, R16
    250            //PORTF_Bit6 = 1;//KT1
    251          //  TIMSK |= (1<<OCIE1A); //разрешили прерывание от таймера.
    252          }
    253          
    254             CLI
   \                     ??rx0_isr_0:
   \   0000004E   94F8               CLI
    255          UCSR0B|=(1<<RXCIE0); //разрешили прерывание от приемника
   \   00000050   9A57               SBI     0x0A, 0x07
    256          if (!r){//приняли кадр
   \   00000052   2388               TST     R24
   \   00000054   F409               BRNE    ??rx0_isr_1
    257          
    258            UCSR0B&=~(1<<RXCIE0);//запрещаем прерывания от приемника
   \   00000056   9857               CBI     0x0A, 0x07
    259          //  red1^=1;
    260          };
    261          };
   \                     ??rx0_isr_1:
   \   00000058   BFAB               OUT     0x3B, R26
   \   0000005A   BF9F               OUT     0x3F, R25
   \   0000005C   9109               LD      R16, Y+
   \   0000005E   9119               LD      R17, Y+
   \   00000060   9129               LD      R18, Y+
   \   00000062   9139               LD      R19, Y+
   \   00000064   9149               LD      R20, Y+
   \   00000066   9159               LD      R21, Y+
   \   00000068   9169               LD      R22, Y+
   \   0000006A   9179               LD      R23, Y+
   \   0000006C   9009               LD      R0, Y+
   \   0000006E   9019               LD      R1, Y+
   \   00000070   9029               LD      R2, Y+
   \   00000072   9039               LD      R3, Y+
   \   00000074   91E9               LD      R30, Y+
   \   00000076   91F9               LD      R31, Y+
   \   00000078   9189               LD      R24, Y+
   \   0000007A   9199               LD      R25, Y+
   \   0000007C   91A9               LD      R26, Y+
   \   0000007E   9518               RETI
   \   00000080                      REQUIRE _A_UCSR0B
   \   00000080                      REQUIRE _A_UDR0
   \   00000080                      REQUIRE _A_OCR1A
   \   00000080                      REQUIRE _A_TCNT1
   \   00000080                      REQUIRE _A_TIFR
    262          #ifdef uart1_ex   
    263          #pragma vector=USART1_RXC_vect
    264          __interrupt void rx1_isr() {
    265          char r;
    266          UCSR1B&=~(1<<RXCIE1);//запрещаем прерывания от приемника
    267              EI
    268          //gron1  
    269          r=recnextch(UDR1,&rec1ctx);
    270          
    271          if (r==10) { //начали прием нового кадра
    272            TCNT3=0;
    273            OCR3A = 0xffff;//68 us
    274            ETIFR = (1<<OCF3A); //сбросили имевшееся прерывание.
    275          //  TIMSK |= (1<<OCIE3A); //разрешили прерывание от таймера.
    276          //PORTF_Bit6 = 1;//KT2
    277          }
    278          
    279             CLI
    280          UCSR1B|=(1<<RXCIE1); //разрешили прерывание от приемника
    281          if (!r){//приняли кадр
    282          //  if (rec1ctx.lrec!=9) redon2;
    283           UCSR1B&=~(1<<RXCIE1);//запрещаем прерывания от приемника
    284          // gron2
    285          };
    286          
    287          };
    288          #endif //uart1
    289          //unsigned char first0,cnt0,first1,cnt1;
    290          //unsigned int size0,size1;
    291           
    292          
    293          
    294          
    295          

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    296          tsenctx sen0ctx;
   \                     sen0ctx:
   \   00000000                      DS 5
    297          #pragma vector=USART0_UDRE_vect

   \                                 In  segment CODE, align 2, keep-with-next
    298          __interrupt void tx0_isr()
   \                     tx0_isr:
    299          {char ch;
   \   00000000   939A               ST      -Y, R25
   \   00000002   938A               ST      -Y, R24
   \   00000004   93FA               ST      -Y, R31
   \   00000006   93EA               ST      -Y, R30
   \   00000008   923A               ST      -Y, R3
   \   0000000A   922A               ST      -Y, R2
   \   0000000C   921A               ST      -Y, R1
   \   0000000E   920A               ST      -Y, R0
   \   00000010   937A               ST      -Y, R23
   \   00000012   936A               ST      -Y, R22
   \   00000014   935A               ST      -Y, R21
   \   00000016   934A               ST      -Y, R20
   \   00000018   933A               ST      -Y, R19
   \   0000001A   932A               ST      -Y, R18
   \   0000001C   931A               ST      -Y, R17
   \   0000001E   930A               ST      -Y, R16
   \   00000020   B78F               IN      R24, 0x3F
   \   00000022   B79B               IN      R25, 0x3B
   \   00000024   9721               SBIW    R29:R28, 1
    300            UCSR0B&=~(1<<UDRIE0); //запрещаем прерывания от передатчика добавил 7.07
   \   00000026   9855               CBI     0x0A, 0x05
    301            EI
   \   00000028   9478               SEI
    302            
    303            if (!getnextch(&ch, &sen0ctx)){
   \   0000002A   ....               LDI     R18, LOW(sen0ctx)
   \   0000002C   ....               LDI     R19, (sen0ctx) >> 8
   \   0000002E   018E               MOVW    R17:R16, R29:R28
   \   00000030   ........           CALL    getnextch
   \   00000034   2300               TST     R16
   \   00000036   F471               BRNE    ??tx0_isr_0
    304            
    305              UDR0=ch;
   \   00000038   8108               LD      R16, Y
   \   0000003A   B90C               OUT     0x0C, R16
    306              addh((sen0ctx.senst<<8)+ch);
   \   0000003C   9130....           LDS     R19, (sen0ctx + 4)
   \   00000040   E020               LDI     R18, 0
   \   00000042   8108               LD      R16, Y
   \   00000044   E010               LDI     R17, 0
   \   00000046   0F02               ADD     R16, R18
   \   00000048   1F13               ADC     R17, R19
   \   0000004A   ........           CALL    addh
    307             // gronw
    308             }else  {
    309                addh(0xbbbb);
    310                UCSR0B&=~(1<<UDRIE0); //запрещаем прерывания от передатчика
    311                UCSR0B|=(1<<TXCIE0); //разрешаем  прерывания на завершение выталкивания посл. байта
    312                //redonw
    313          //      SEND0OFF
    314          //      redonw
    315          //      UCSR0B|=(1<<RXCIE0);//разрешаем прерывания от приемника
    316                return; //добавил 7.07
    317            }
    318            CLI
   \   0000004E   94F8               CLI
    319            UCSR0B|=(1<<UDRIE0); //разрешаем прерывания от передатчика добавил 7.07
   \   00000050   9A55               SBI     0x0A, 0x05
    320          };
   \   00000052   C006               RJMP    ??tx0_isr_1
   \                     ??tx0_isr_0:
   \   00000054   EB0B               LDI     R16, 187
   \   00000056   EB1B               LDI     R17, 187
   \   00000058   ........           CALL    addh
   \   0000005C   9855               CBI     0x0A, 0x05
   \   0000005E   9A56               SBI     0x0A, 0x06
   \                     ??tx0_isr_1:
   \   00000060   9621               ADIW    R29:R28, 1
   \   00000062   BF9B               OUT     0x3B, R25
   \   00000064   BF8F               OUT     0x3F, R24
   \   00000066   9109               LD      R16, Y+
   \   00000068   9119               LD      R17, Y+
   \   0000006A   9129               LD      R18, Y+
   \   0000006C   9139               LD      R19, Y+
   \   0000006E   9149               LD      R20, Y+
   \   00000070   9159               LD      R21, Y+
   \   00000072   9169               LD      R22, Y+
   \   00000074   9179               LD      R23, Y+
   \   00000076   9009               LD      R0, Y+
   \   00000078   9019               LD      R1, Y+
   \   0000007A   9029               LD      R2, Y+
   \   0000007C   9039               LD      R3, Y+
   \   0000007E   91E9               LD      R30, Y+
   \   00000080   91F9               LD      R31, Y+
   \   00000082   9189               LD      R24, Y+
   \   00000084   9199               LD      R25, Y+
   \   00000086   9518               RETI
   \   00000088                      REQUIRE _A_UCSR0B
   \   00000088                      REQUIRE _A_UDR0
    321          

   \                                 In  segment CODE, align 2, keep-with-next
    322          short chkfrm(char adr,trecctx *ctx){//проверка корректности принятого кадра
   \                     chkfrm:
   \   00000000   ........           CALL    ?PROLOGUE4_L09
   \   00000004   2F80               MOV     R24, R16
   \   00000006   01D9               MOVW    R27:R26, R19:R18
    323          /*
    324          возвращает 0 - все 0К
    325          1 - не сошлась длина
    326          2 - это кадр не для 1-й станции
    327          3 - это кадр не от мастера
    328          4 - ошибка СRC
    329          */
    330          
    331          //redon3
    332          //gron4
    333          if (ctx->lrec!=(ctx->rbuf[0]+((int)(ctx->rbuf[1])<<8))) return 1;
   \   00000008   914D               LD      R20, X+
   \   0000000A   915C               LD      R21, X
   \   0000000C   9711               SBIW    R27:R26, 1
   \   0000000E   01FD               MOVW    R31:R30, R27:R26
   \   00000010   8123               LDD     R18, Z+3
   \   00000012   E030               LDI     R19, 0
   \   00000014   01FD               MOVW    R31:R30, R27:R26
   \   00000016   8114               LDD     R17, Z+4
   \   00000018   E000               LDI     R16, 0
   \   0000001A   0F02               ADD     R16, R18
   \   0000001C   1F13               ADC     R17, R19
   \   0000001E   1740               CP      R20, R16
   \   00000020   0751               CPC     R21, R17
   \   00000022   F019               BREQ    ??chkfrm_0
   \   00000024   E001               LDI     R16, 1
   \   00000026   E010               LDI     R17, 0
   \   00000028   C01D               RJMP    ??chkfrm_1
    334          
    335          if (ctx->rbuf[AF]!=adr) return 2;
   \                     ??chkfrm_0:
   \   0000002A   01FD               MOVW    R31:R30, R27:R26
   \   0000002C   8105               LDD     R16, Z+5
   \   0000002E   1708               CP      R16, R24
   \   00000030   F019               BREQ    ??chkfrm_2
   \   00000032   E002               LDI     R16, 2
   \   00000034   E010               LDI     R17, 0
   \   00000036   C016               RJMP    ??chkfrm_1
    336          //redon3
    337          if ((ctx->rbuf[CF]&0x80)!=0) return 3;
   \                     ??chkfrm_2:
   \   00000038   01FD               MOVW    R31:R30, R27:R26
   \   0000003A   8106               LDD     R16, Z+6
   \   0000003C   FF07               SBRS    R16, 7
   \   0000003E   C003               RJMP    ??chkfrm_3
   \   00000040   E003               LDI     R16, 3
   \   00000042   E010               LDI     R17, 0
   \   00000044   C00F               RJMP    ??chkfrm_1
    338          
    339          if(getcrc((UCHAR *)(ctx->rbuf), ctx->lrec)) return 4;
   \                     ??chkfrm_3:
   \   00000046   912D               LD      R18, X+
   \   00000048   913C               LD      R19, X
   \   0000004A   9711               SBIW    R27:R26, 1
   \   0000004C   018D               MOVW    R17:R16, R27:R26
   \   0000004E   5F0D               SUBI    R16, 253
   \   00000050   4F1F               SBCI    R17, 255
   \   00000052   ........           CALL    getcrc
   \   00000056   2B01               OR      R16, R17
   \   00000058   F019               BREQ    ??chkfrm_4
   \   0000005A   E004               LDI     R16, 4
   \   0000005C   E010               LDI     R17, 0
   \   0000005E   C002               RJMP    ??chkfrm_1
    340          //redon2
    341          return 0;
   \                     ??chkfrm_4:
   \   00000060   E000               LDI     R16, 0
   \   00000062   E010               LDI     R17, 0
   \                     ??chkfrm_1:
   \   00000064   E0E4               LDI     R30, 4
   \   00000066   ........           JMP     ?EPILOGUE_B4_L09
    342          }
    343          
    344          typedef struct {
    345               int len;
    346               char adr;
    347               char cf;
    348               char asdu[sbuf_size-2];
    349          }tsbuf;

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    350          tsbuf sbuf;
   \                     sbuf:
   \   00000000                      DS 1026
    351          
    352          

   \                                 In  segment CODE, align 2, keep-with-next
    353          void _copy(char * source,char *dest,UINT len){
   \                     _copy:
   \                     ??_copy_0:
    354          while (len) {*dest=*source; dest++;source++;len--;};
   \   00000000   2F64               MOV     R22, R20
   \   00000002   2B65               OR      R22, R21
   \   00000004   F059               BREQ    ??_copy_1
   \   00000006   01F8               MOVW    R31:R30, R17:R16
   \   00000008   8160               LD      R22, Z
   \   0000000A   01F9               MOVW    R31:R30, R19:R18
   \   0000000C   8360               ST      Z, R22
   \   0000000E   5F2F               SUBI    R18, 255
   \   00000010   4F3F               SBCI    R19, 255
   \   00000012   5F0F               SUBI    R16, 255
   \   00000014   4F1F               SBCI    R17, 255
   \   00000016   5041               SUBI    R20, 1
   \   00000018   4050               SBCI    R21, 0
   \   0000001A   CFF2               RJMP    ??_copy_0
    355          }
   \                     ??_copy_1:
   \   0000001C   9508               RET
    356          

   \                                 In  segment CODE, align 2, keep-with-next
    357          void sendexept(){
   \                     sendexept:
   \   00000000   ........           CALL    ?PROLOGUE4_L09
    358          int crc;
    359                 // addh(0xaaa1); 
    360                 sbuf.len=rec0ctx.rbuf[0]+ (rec0ctx.rbuf[1]<<8);
   \   00000004   9120....           LDS     R18, (rec0ctx + 3)
   \   00000008   E030               LDI     R19, 0
   \   0000000A   9110....           LDS     R17, (rec0ctx + 4)
   \   0000000E   E000               LDI     R16, 0
   \   00000010   0F02               ADD     R16, R18
   \   00000012   1F13               ADC     R17, R19
   \   00000014   ....               LDI     R30, LOW(sbuf)
   \   00000016   ....               LDI     R31, (sbuf) >> 8
   \   00000018   8300               ST      Z, R16
   \   0000001A   8311               STD     Z+1, R17
    361                 sbuf.len++;
   \   0000001C   ....               LDI     R30, LOW(sbuf)
   \   0000001E   ....               LDI     R31, (sbuf) >> 8
   \   00000020   8100               LD      R16, Z
   \   00000022   8111               LDD     R17, Z+1
   \   00000024   5F0F               SUBI    R16, 255
   \   00000026   4F1F               SBCI    R17, 255
   \   00000028   8300               ST      Z, R16
   \   0000002A   8311               STD     Z+1, R17
    362                 sbuf.adr=adr;
   \   0000002C   9100....           LDS     R16, adr
   \   00000030   9300....           STS     (sbuf + 2), R16
    363                 sbuf.cf=0x80|FCexept;
   \   00000034   E80F               LDI     R16, 143
   \   00000036   9300....           STS     (sbuf + 3), R16
    364                 sbuf.asdu[0]=ex_no_support;
   \   0000003A   E001               LDI     R16, 1
   \   0000003C   9300....           STS     (sbuf + 4), R16
    365                 _copy(&rec0ctx.rbuf[3],&sbuf.asdu[1],rec0ctx.lrec-5);  
   \   00000040   ....               LDI     R30, LOW(rec0ctx)
   \   00000042   ....               LDI     R31, (rec0ctx) >> 8
   \   00000044   81A0               LD      R26, Z
   \   00000046   81B1               LDD     R27, Z+1
   \   00000048   9715               SBIW    R27:R26, 5
   \   0000004A   01AD               MOVW    R21:R20, R27:R26
   \   0000004C   ....               LDI     R18, LOW((sbuf + 5))
   \   0000004E   ....               LDI     R19, HIGH((sbuf + 5))
   \   00000050   ....               LDI     R16, LOW((rec0ctx + 6))
   \   00000052   ....               LDI     R17, HIGH((rec0ctx + 6))
   \   00000054   ....               RCALL   _copy
    366                 crc=getcrc((UCHAR *)&sbuf, sbuf.len-2);
   \   00000056   ....               LDI     R30, LOW(sbuf)
   \   00000058   ....               LDI     R31, (sbuf) >> 8
   \   0000005A   8120               LD      R18, Z
   \   0000005C   8131               LDD     R19, Z+1
   \   0000005E   5022               SUBI    R18, 2
   \   00000060   4030               SBCI    R19, 0
   \   00000062   ....               LDI     R16, LOW(sbuf)
   \   00000064   ....               LDI     R17, (sbuf) >> 8
   \   00000066   ........           CALL    getcrc
   \   0000006A   01C8               MOVW    R25:R24, R17:R16
    367                 sbuf.asdu[sbuf.len-6]=crc>>8;
   \   0000006C   018C               MOVW    R17:R16, R25:R24
   \   0000006E   2F01               MOV     R16, R17
   \   00000070   0F11               LSL     R17
   \   00000072   0B11               SBC     R17, R17
   \   00000074   ....               LDI     R30, LOW(sbuf)
   \   00000076   ....               LDI     R31, (sbuf) >> 8
   \   00000078   8120               LD      R18, Z
   \   0000007A   8131               LDD     R19, Z+1
   \   0000007C   01F9               MOVW    R31:R30, R19:R18
   \   0000007E   ....               SUBI    R30, LOW((-(sbuf - 2) & 0xFFFF))
   \   00000080   ....               SBCI    R31, HIGH((-(sbuf - 2) & 0xFFFF))
   \   00000082   8300               ST      Z, R16
    368                 sbuf.asdu[sbuf.len-5]=crc&0xff; 
   \   00000084   2F08               MOV     R16, R24
   \   00000086   ....               LDI     R30, LOW(sbuf)
   \   00000088   ....               LDI     R31, (sbuf) >> 8
   \   0000008A   8120               LD      R18, Z
   \   0000008C   8131               LDD     R19, Z+1
   \   0000008E   01F9               MOVW    R31:R30, R19:R18
   \   00000090   ....               SUBI    R30, LOW((-(sbuf - 1) & 0xFFFF))
   \   00000092   ....               SBCI    R31, HIGH((-(sbuf - 1) & 0xFFFF))
   \   00000094   8300               ST      Z, R16
    369                 inisend(sbuf.len,(char *)&sbuf,&sen0ctx);
   \   00000096   ....               LDI     R20, LOW(sen0ctx)
   \   00000098   ....               LDI     R21, (sen0ctx) >> 8
   \   0000009A   ....               LDI     R18, LOW(sbuf)
   \   0000009C   ....               LDI     R19, (sbuf) >> 8
   \   0000009E   ....               LDI     R30, LOW(sbuf)
   \   000000A0   ....               LDI     R31, (sbuf) >> 8
   \   000000A2   8100               LD      R16, Z
   \   000000A4   8111               LDD     R17, Z+1
   \   000000A6   ........           CALL    inisend
    370                 SEND0ON 
    371                 UCSR0B|=(1<<UDRIE0); //разрешаем прерывания от передатчика
   \   000000AA   9A55               SBI     0x0A, 0x05
    372          }
   \   000000AC   E0E4               LDI     R30, 4
   \   000000AE   ........           JMP     ?EPILOGUE_B4_L09
   \   000000B2                      REQUIRE _A_UCSR0B
    373          

   \                                 In  segment CODE, align 2, keep-with-next
    374          inisendfrm(int len,char * sbuf){
   \                     inisendfrm:
   \   00000000   ........           CALL    ?PROLOGUE6_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004   01C8               MOVW    R25:R24, R17:R16
   \   00000006   01D9               MOVW    R27:R26, R19:R18
    375          int crc;
    376                 sbuf[0]=len&0xff;
   \   00000008   2F08               MOV     R16, R24
   \   0000000A   930C               ST      X, R16
    377                 sbuf[1]=len>>8;
   \   0000000C   018C               MOVW    R17:R16, R25:R24
   \   0000000E   2F01               MOV     R16, R17
   \   00000010   0F11               LSL     R17
   \   00000012   0B11               SBC     R17, R17
   \   00000014   01FD               MOVW    R31:R30, R27:R26
   \   00000016   8301               STD     Z+1, R16
    378                 sbuf[2]=adr;
   \   00000018   9100....           LDS     R16, adr
   \   0000001C   01FD               MOVW    R31:R30, R27:R26
   \   0000001E   8302               STD     Z+2, R16
    379                 crc=getcrc((UCHAR *)sbuf, len-2);
   \   00000020   019C               MOVW    R19:R18, R25:R24
   \   00000022   5022               SUBI    R18, 2
   \   00000024   4030               SBCI    R19, 0
   \   00000026   018D               MOVW    R17:R16, R27:R26
   \   00000028   ........           CALL    getcrc
   \   0000002C   0128               MOVW    R5:R4, R17:R16
    380                 sbuf[len-2]=crc>>8;
   \   0000002E   0182               MOVW    R17:R16, R5:R4
   \   00000030   2F01               MOV     R16, R17
   \   00000032   0F11               LSL     R17
   \   00000034   0B11               SBC     R17, R17
   \   00000036   01FD               MOVW    R31:R30, R27:R26
   \   00000038   0FE8               ADD     R30, R24
   \   0000003A   1FF9               ADC     R31, R25
   \   0000003C   9732               SBIW    R31:R30, 2
   \   0000003E   8300               ST      Z, R16
    381                 sbuf[len-1]=crc&0xff;  
   \   00000040   2D04               MOV     R16, R4
   \   00000042   01FD               MOVW    R31:R30, R27:R26
   \   00000044   0FE8               ADD     R30, R24
   \   00000046   1FF9               ADC     R31, R25
   \   00000048   9731               SBIW    R31:R30, 1
   \   0000004A   8300               ST      Z, R16
    382                 inisend(len,sbuf,&sen0ctx);
   \   0000004C   ....               LDI     R20, LOW(sen0ctx)
   \   0000004E   ....               LDI     R21, (sen0ctx) >> 8
   \   00000050   019D               MOVW    R19:R18, R27:R26
   \   00000052   018C               MOVW    R17:R16, R25:R24
   \   00000054   ........           CALL    inisend
    383                 SEND0ON 
    384                 UCSR0B|=(1<<UDRIE0); //разрешаем прерывания от передатчика
   \   00000058   9A55               SBI     0x0A, 0x05
    385                 inirec(&rec0ctx);//переинициируем прием. Вызов обязателен!!!
   \   0000005A   ....               LDI     R16, LOW(rec0ctx)
   \   0000005C   ....               LDI     R17, (rec0ctx) >> 8
   \   0000005E   ........           CALL    inirec
    386          }
   \   00000062   E0E6               LDI     R30, 6
   \   00000064   ........           JMP     ?EPILOGUE_B6_L09
   \   00000068                      REQUIRE _A_UCSR0B
    387          
    388          
    389          extern unsigned int FileSIZE[32];
    390          extern unsigned char FSTATUS[32];
    391          

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    392          char sendbuf[200];
   \                     sendbuf:
   \   00000000                      DS 200

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    393          char prbufcur;//номер тек буфера для зап
   \                     prbufcur:
   \   00000000                      DS 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    394          int curoffset=0;
   \                     curoffset:
   \   00000000                      DS 2

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    395          char * curbuf;
   \                     curbuf:
   \   00000000                      DS 2
    396          

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    397          char prbuf0[prbufsize];
   \                     prbuf0:
   \   00000000                      DS 900

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    398          char prbuf1[prbufsize];
   \                     prbuf1:
   \   00000000                      DS 900

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    399          int offset1,offset2;
   \                     offset1:
   \   00000000                      DS 2

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \                     offset2:
   \   00000000                      DS 2

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    400          tprofile profile;     
   \                     profile:
   \   00000000                      DS 69
    401          

   \                                 In  segment CODE, align 2, keep-with-next
    402          void setch(int absad,char ch){
   \                     setch:
   \   00000000   01B8               MOVW    R23:R22, R17:R16
    403          
    404           if( *(( unsigned int __eeprom *)(absad))==ch)return;//выход по совпадению, запись не нужна
   \   00000002   01AB               MOVW    R21:R20, R23:R22
   \   00000004   ........           CALL    __eeget16_16
   \   00000008   E030               LDI     R19, 0
   \   0000000A   1702               CP      R16, R18
   \   0000000C   0713               CPC     R17, R19
   \   0000000E   F049               BREQ    ??setch_0
    405           
    406            while(EECR & (1<<EEWE));    /* Wait for completion of previous write */
   \                     ??setch_1:
   \   00000010   99E1               SBIC    0x1C, 0x01
   \   00000012   CFFE               RJMP    ??setch_1
    407          __disable_interrupt();
   \   00000014   94F8               CLI
    408          /* Set up address and data registers */
    409          EEAR = absad;
   \   00000016   BB7F               OUT     0x1F, R23
   \   00000018   BB6E               OUT     0x1E, R22
    410          EEDR = ch;
   \   0000001A   BB2D               OUT     0x1D, R18
    411          /* Write logical one to EEMWE */
    412          EECR |= (1<<EEMWE);
   \   0000001C   9AE2               SBI     0x1C, 0x02
    413          /* Start eeprom write by setting EEWE */
    414          EECR |= (1<<EEWE);   
   \   0000001E   9AE1               SBI     0x1C, 0x01
    415          __enable_interrupt();
   \   00000020   9478               SEI
    416          //  while(EECR & (1<<EEWE));    
    417          }
   \                     ??setch_0:
   \   00000022   9508               RET
   \   00000024                      REQUIRE _A_EECR
   \   00000024                      REQUIRE _A_EEDR
   \   00000024                      REQUIRE _A_EEAR
    418          ////////////////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    419          void read_settings(){// чтение параметров в ОЗУ
   \                     read_settings:
   \   00000000   2F79               MOV     R23, R25
   \   00000002   2E08               MOV     R0, R24
    420          /////////////////////////////////////////////////////////////////////////////////////////////
    421            char * p=(char *)&profile;
   \   00000004   ....               LDI     R16, LOW(profile)
   \   00000006   ....               LDI     R17, (profile) >> 8
   \   00000008   01C8               MOVW    R25:R24, R17:R16
    422            char ch;
    423            for(int i=0;i<sizeof(tprofile);i++ ){
   \   0000000A   E040               LDI     R20, 0
   \   0000000C   E050               LDI     R21, 0
   \                     ??read_settings_0:
   \   0000000E   3445               CPI     R20, 69
   \   00000010   E000               LDI     R16, 0
   \   00000012   0750               CPC     R21, R16
   \   00000014   F450               BRCC    ??read_settings_1
    424               ch=*(( unsigned char __eeprom *)i);
   \   00000016   ........           CALL    __eeget8_16
   \   0000001A   2F60               MOV     R22, R16
    425               *p=ch;
   \   0000001C   01FC               MOVW    R31:R30, R25:R24
   \   0000001E   8360               ST      Z, R22
    426               p++;
   \   00000020   9601               ADIW    R25:R24, 1
    427               __watchdog_reset();
   \   00000022   95A8               WDR
    428            };
   \   00000024   5F4F               SUBI    R20, 255
   \   00000026   4F5F               SBCI    R21, 255
   \   00000028   CFF2               RJMP    ??read_settings_0
    429            if(profile.cnt==0xff){ //eeprom чистое, задаем параметры по умолчанию
   \                     ??read_settings_1:
   \   0000002A   9100....           LDS     R16, profile
   \   0000002E   3F0F               CPI     R16, 255
   \   00000030   F599               BRNE    ??read_settings_2
    430               profile.cnt=2;
   \   00000032   E002               LDI     R16, 2
   \   00000034   9300....           STS     profile, R16
    431               profile.curr[0]=100;
   \   00000038   E604               LDI     R16, 100
   \   0000003A   E010               LDI     R17, 0
   \   0000003C   ....               LDI     R30, LOW(profile)
   \   0000003E   ....               LDI     R31, (profile) >> 8
   \   00000040   8301               STD     Z+1, R16
   \   00000042   8312               STD     Z+2, R17
    432               profile.curr[1]=0;
   \   00000044   E000               LDI     R16, 0
   \   00000046   E010               LDI     R17, 0
   \   00000048   ....               LDI     R30, LOW(profile)
   \   0000004A   ....               LDI     R31, (profile) >> 8
   \   0000004C   8303               STD     Z+3, R16
   \   0000004E   8314               STD     Z+4, R17
    433               profile.dur[0]=50;
   \   00000050   E302               LDI     R16, 50
   \   00000052   E010               LDI     R17, 0
   \   00000054   E020               LDI     R18, 0
   \   00000056   E030               LDI     R19, 0
   \   00000058   ....               LDI     R30, LOW(profile)
   \   0000005A   ....               LDI     R31, (profile) >> 8
   \   0000005C   8B05               STD     Z+21, R16
   \   0000005E   8B16               STD     Z+22, R17
   \   00000060   8B27               STD     Z+23, R18
   \   00000062   8F30               STD     Z+24, R19
    434               profile.dur[1]=50;
   \   00000064   E302               LDI     R16, 50
   \   00000066   E010               LDI     R17, 0
   \   00000068   E020               LDI     R18, 0
   \   0000006A   E030               LDI     R19, 0
   \   0000006C   ....               LDI     R30, LOW(profile)
   \   0000006E   ....               LDI     R31, (profile) >> 8
   \   00000070   8F01               STD     Z+25, R16
   \   00000072   8F12               STD     Z+26, R17
   \   00000074   8F23               STD     Z+27, R18
   \   00000076   8F34               STD     Z+28, R19
    435               profile.act_cur=100;
   \   00000078   E604               LDI     R16, 100
   \   0000007A   9300....           STS     (profile + 61), R16
    436               profile.act_cur_level=90;
   \   0000007E   E50A               LDI     R16, 90
   \   00000080   9300....           STS     (profile + 62), R16
    437               profile.act_time=600;
   \   00000084   E508               LDI     R16, 88
   \   00000086   E012               LDI     R17, 2
   \   00000088   E020               LDI     R18, 0
   \   0000008A   E030               LDI     R19, 0
   \   0000008C   ....               LDI     R30, LOW((profile + 63))
   \   0000008E   ....               LDI     R31, HIGH((profile + 63))
   \   00000090   8300               ST      Z, R16
   \   00000092   8311               STD     Z+1, R17
   \   00000094   8322               STD     Z+2, R18
   \   00000096   8333               STD     Z+3, R19
    438            }
    439          }
   \                     ??read_settings_2:
   \   00000098   2D80               MOV     R24, R0
   \   0000009A   2F97               MOV     R25, R23
   \   0000009C   9508               RET
    440            
    441            
    442          
    443          ////////////////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    444          void wr_settings(){// запись параметров в eeprom 
   \                     wr_settings:
   \   00000000   ........           CALL    ?PROLOGUE4_L09
    445          /////////////////////////////////////////////////////////////////////////////////////////////
    446            char * p=(char *)&profile;
   \   00000004   ....               LDI     R16, LOW(profile)
   \   00000006   ....               LDI     R17, (profile) >> 8
   \   00000008   01D8               MOVW    R27:R26, R17:R16
    447            __watchdog_reset();
   \   0000000A   95A8               WDR
    448            for(int i=0;i<sizeof(tprofile);i++){
   \   0000000C   E080               LDI     R24, 0
   \   0000000E   E090               LDI     R25, 0
   \                     ??wr_settings_0:
   \   00000010   3485               CPI     R24, 69
   \   00000012   E000               LDI     R16, 0
   \   00000014   0790               CPC     R25, R16
   \   00000016   F440               BRCC    ??wr_settings_1
    449               setch(i,*p++);
   \   00000018   01FD               MOVW    R31:R30, R27:R26
   \   0000001A   8120               LD      R18, Z
   \   0000001C   018C               MOVW    R17:R16, R25:R24
   \   0000001E   ....               RCALL   setch
   \   00000020   9611               ADIW    R27:R26, 1
    450               __watchdog_reset();
   \   00000022   95A8               WDR
    451            }
   \   00000024   9601               ADIW    R25:R24, 1
   \   00000026   CFF4               RJMP    ??wr_settings_0
    452          }
   \                     ??wr_settings_1:
   \   00000028   E0E4               LDI     R30, 4
   \   0000002A   ........           JMP     ?EPILOGUE_B4_L09
    453                

   \                                 In  segment CODE, align 2, keep-with-next
    454          void setrg(UINT address,UINT rg){
   \                     setrg:
   \   00000000   ........           CALL    ?PROLOGUE4_L09
   \   00000004   01D8               MOVW    R27:R26, R17:R16
   \   00000006   01C9               MOVW    R25:R24, R19:R18
    455            setch(address*2,rg&0xff);
   \   00000008   2F28               MOV     R18, R24
   \   0000000A   018D               MOVW    R17:R16, R27:R26
   \   0000000C   0F00               LSL     R16
   \   0000000E   1F11               ROL     R17
   \   00000010   ....               RCALL   setch
    456             while(EECR & (1<<EEWE));    /* Wait for completion of previous write */
   \                     ??setrg_0:
   \   00000012   99E1               SBIC    0x1C, 0x01
   \   00000014   CFFE               RJMP    ??setrg_0
    457            setch(address*2+1,rg>>8);
   \   00000016   019C               MOVW    R19:R18, R25:R24
   \   00000018   2F23               MOV     R18, R19
   \   0000001A   E030               LDI     R19, 0
   \   0000001C   018D               MOVW    R17:R16, R27:R26
   \   0000001E   0F00               LSL     R16
   \   00000020   1F11               ROL     R17
   \   00000022   5F0F               SUBI    R16, 255
   \   00000024   4F1F               SBCI    R17, 255
   \   00000026   ....               RCALL   setch
    458            while(EECR & (1<<EEWE));    /* Wait for completion of previous write */
   \                     ??setrg_1:
   \   00000028   99E1               SBIC    0x1C, 0x01
   \   0000002A   CFFE               RJMP    ??setrg_1
    459          };
   \   0000002C   E0E4               LDI     R30, 4
   \   0000002E   ........           JMP     ?EPILOGUE_B4_L09
   \   00000032                      REQUIRE _A_EECR
    460          //#define answerb_size 100
    461          //char answerb[answerb_size];

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    462          char oldportg=0;
   \                     oldportg:
   \   00000000                      DS 1

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    463          char need_portgsel;
   \                     need_portgsel:
   \   00000000                      DS 1
    464          ///////////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    465          void sendack(char retcode){
   \                     sendack:
   \   00000000   938A               ST      -Y, R24
   \   00000002   2F80               MOV     R24, R16
    466          ///////////////////////////////////////////////////////////////////////////////////////
    467          //          answerb[3]=FCset_relays+0x80;
    468             sendbuf[3]=rec0ctx.rbuf[CF]|0x80 ;
   \   00000004   9100....           LDS     R16, (rec0ctx + 6)
   \   00000008   6800               ORI     R16, 0x80
   \   0000000A   9300....           STS     (sendbuf + 3), R16
    469             sendbuf[4]=retcode;
   \   0000000E   9380....           STS     (sendbuf + 4), R24
    470             inisendfrm(5+2,sendbuf);
   \   00000012   ....               LDI     R18, LOW(sendbuf)
   \   00000014   ....               LDI     R19, (sendbuf) >> 8
   \   00000016   E007               LDI     R16, 7
   \   00000018   E010               LDI     R17, 0
   \   0000001A   ....               RCALL   inisendfrm
    471          }
   \   0000001C   9189               LD      R24, Y+
   \   0000001E   9508               RET

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
    472          int senlen=0;//длина кадра на передачу в буфере forsend
   \                     senlen:
   \   00000000                      DS 2
    473          void ini_workbyprofile();
    474          void ini_activation();
    475          ///////////////////////////////////////////////////////////////////////////////////////

   \                                 In  segment CODE, align 2, keep-with-next
    476          void req0handle(){
   \                     req0handle:
   \   00000000   ........           CALL    ?PROLOGUE4_L09
    477          ///////////////////////////////////////////////////////////////////////////////////////
    478          //char senbuf[]="abcd";
    479          //int r;
    480          //gr3^=1;
    481          //int s;
    482          //char res;
    483          
    484          if (rec0ctx.recst==3) { //был принят калр 3
   \   00000004   9100....           LDS     R16, (rec0ctx + 2)
   \   00000008   3003               CPI     R16, 3
   \   0000000A   F009               BREQ    $+2+2
   \   0000000C   C112               RJMP    ??req0handle_0
    485          
    486            if(chkfrm(adr,&rec0ctx)) goto errfrm0 ;
   \   0000000E   ....               LDI     R18, LOW(rec0ctx)
   \   00000010   ....               LDI     R19, (rec0ctx) >> 8
   \   00000012   9100....           LDS     R16, adr
   \   00000016   ....               RCALL   chkfrm
   \   00000018   2B01               OR      R16, R17
   \   0000001A   F031               BREQ    ??req0handle_1
    487            switch (rec0ctx.rbuf[CF]){
    488               //------------------------------------------------------------------------  
    489            
    490            case FClink: //установка связи     
    491                    //answerb[0]=adr;
    492                    sendbuf[3]=FClink+0x80;
    493                    sendbuf[4]=1;
    494                    sendbuf[5]=0;
    495                    sendbuf[6]=ver;
    496                    sendbuf[7]=subver;
    497                    sendbuf[8]=work_mode;
    498                    memcpy(&sendbuf[9],&profile,sizeof(tprofile));
    499                    inisendfrm(9+2+sizeof(tprofile),sendbuf);
    500                    break;
    501                 
    502          /*     
    503               case FCget_hist:{
    504                
    505                    sendbuf[3]=FCset_ref+0x80;
    506                    for (s=0;s<sizeof(hist.harr)/2;s++){
    507                      sendbuf[4+s*2]=hist.harr[s];
    508                      sendbuf[4+s*2+1]=hist.harr[s]>>8;
    509                    }          
    510                    inisendfrm(sizeof(hist),(char *)&sendbuf);
    511                    break;
    512               }
    513          */          
    514               case FCgetbat://отдать сост. батарей
    515              {
    516                sendbuf[3]=FCgetbat+0x80;      
    517          //      sendbuf[4]=0;
    518                sendbuf[4]=work_mode;
    519                memcpy(&sendbuf[5],batt,sizeof(tbatt)*4);
    520                   inisendfrm(4+2+sizeof(tbatt)*4,(char *)&sendbuf);
    521          
    522               }
    523               break;
    524            case FCsetprofile://запись конфигурации
    525               sendack(0);
    526               inirec(&rec0ctx);//переинициируем прием. Вызвали раньше, чтобы не мешалась долгая работа процедуры wr_settings
    527               __watchdog_reset();
    528               memcpy(&profile,&rec0ctx.rbuf[CF+1],sizeof(tprofile));
    529               wr_settings();
    530               if(work_mode!=10)ini_activation();
    531               else ini_workbyprofile();
    532               return;
    533            case FCsetactivation://переход в режим активации
    534               sendack(0);
    535               ini_activation();
    536               break;
    537            case FCsetbyprofile://переход в режим разряда по профилю
    538               sendack(0);
    539               ini_workbyprofile();
    540               stepcnt=0;
    541               break;
    542            case FCresetfrmcnt://
    543               sendack(0);
    544               frmcnt=0;
    545               break;
    546            case FCgetitems:
    547              if((senlen!=0)&&(frmcnt==rec0ctx.rbuf[4])){
    548                //идет переспрос;
    549                inisendfrm(senlen,forsend);
    550              }else{
    551                //запрос нового буфера
    552                frmcnt=rec0ctx.rbuf[4];
    553                if(forsend==prbuf0){
    554                  forsend=prbuf1; //передаем с 1-го, заполняем 0-й
    555                  curbuf=prbuf0;
    556                  senlen=curoffset+1;
    557          //        offset0=0;//установили признак свободности буфера
    558          //         offset1=framenum+2;
    559                  curoffset=  framenum+2;
    560                  
    561                }else{
    562                  forsend=prbuf0;
    563                  curbuf=prbuf1;
    564                  senlen=curoffset+1;
    565                  curoffset=  framenum+2;
    566                }
    567                 curbuf[framenum+1]=0;//сбросили флаг переполнения
    568                forsend[CF]=0x80+FCgetitems;
    569                forsend[framenum]=frmcnt;
    570                 inisendfrm(senlen,(char *)forsend);
    571                 
    572              }
    573              
    574              break;
    575            case FCcalibr://инициация процедуры калибровки
    576               sendack(0);
    577               inirec(&rec0ctx);//переинициируем прием. Вызвали раньше, чтобы не мешалась долгая работа процедуры 
    578               __watchdog_reset();
    579               calibration();
    580              return;
    581              
    582          
    583            default: sendexept();  
    584            }
    585            inirec(&rec0ctx);//переинициируем прием. Вызов обязателен!!!
    586            return;
    587          errfrm0:   
    588             inirec(&rec0ctx);//переинициируем прием. Вызов обязателен!!!
   \   0000001C   ....               LDI     R16, LOW(rec0ctx)
   \   0000001E   ....               LDI     R17, (rec0ctx) >> 8
   \   00000020   ........           CALL    inirec
    589             UCSR0B|=(1<<RXCIE0); //разрешили прерывание от приемника
   \   00000024   9A57               SBI     0x0A, 0x07
   \   00000026   C105               RJMP    ??req0handle_0
   \                     ??req0handle_1:
   \   00000028   9100....           LDS     R16, (rec0ctx + 6)
   \   0000002C   5001               SUBI    R16, 1
   \   0000002E   F0A9               BREQ    ??req0handle_2
   \   00000030   5003               SUBI    R16, 3
   \   00000032   F1A1               BREQ    ??req0handle_3
   \   00000034   950A               DEC     R16
   \   00000036   F409               BRNE    $+2+2
   \   00000038   C046               RJMP    ??req0handle_4
   \   0000003A   950A               DEC     R16
   \   0000003C   F409               BRNE    $+2+2
   \   0000003E   C05D               RJMP    ??req0handle_5
   \   00000040   950A               DEC     R16
   \   00000042   F409               BRNE    $+2+2
   \   00000044   C05F               RJMP    ??req0handle_6
   \   00000046   950A               DEC     R16
   \   00000048   F409               BRNE    $+2+2
   \   0000004A   C064               RJMP    ??req0handle_7
   \   0000004C   950A               DEC     R16
   \   0000004E   F409               BRNE    $+2+2
   \   00000050   C067               RJMP    ??req0handle_8
   \   00000052   950A               DEC     R16
   \   00000054   F409               BRNE    $+2+2
   \   00000056   C0DE               RJMP    ??req0handle_9
   \   00000058   C0E7               RJMP    ??req0handle_10
   \                     ??req0handle_2:
   \   0000005A   E801               LDI     R16, 129
   \   0000005C   9300....           STS     (sendbuf + 3), R16
   \   00000060   E001               LDI     R16, 1
   \   00000062   9300....           STS     (sendbuf + 4), R16
   \   00000066   E000               LDI     R16, 0
   \   00000068   9300....           STS     (sendbuf + 5), R16
   \   0000006C   E001               LDI     R16, 1
   \   0000006E   9300....           STS     (sendbuf + 6), R16
   \   00000072   E004               LDI     R16, 4
   \   00000074   9300....           STS     (sendbuf + 7), R16
   \   00000078   9100....           LDS     R16, work_mode
   \   0000007C   9300....           STS     (sendbuf + 8), R16
   \   00000080   E445               LDI     R20, 69
   \   00000082   E050               LDI     R21, 0
   \   00000084   ....               LDI     R18, LOW(profile)
   \   00000086   ....               LDI     R19, (profile) >> 8
   \   00000088   ....               LDI     R16, LOW((sendbuf + 9))
   \   0000008A   ....               LDI     R17, HIGH((sendbuf + 9))
   \   0000008C   ........           CALL    memcpy
   \   00000090   ....               LDI     R18, LOW(sendbuf)
   \   00000092   ....               LDI     R19, (sendbuf) >> 8
   \   00000094   E500               LDI     R16, 80
   \   00000096   E010               LDI     R17, 0
   \   00000098   ....               RCALL   inisendfrm
   \   0000009A   C0C7               RJMP    ??req0handle_11
   \                     ??req0handle_3:
   \   0000009C   E804               LDI     R16, 132
   \   0000009E   9300....           STS     (sendbuf + 3), R16
   \   000000A2   9100....           LDS     R16, work_mode
   \   000000A6   9300....           STS     (sendbuf + 4), R16
   \   000000AA   E54C               LDI     R20, 92
   \   000000AC   E050               LDI     R21, 0
   \   000000AE   ....               LDI     R18, LOW(batt)
   \   000000B0   ....               LDI     R19, (batt) >> 8
   \   000000B2   ....               LDI     R16, LOW((sendbuf + 5))
   \   000000B4   ....               LDI     R17, HIGH((sendbuf + 5))
   \   000000B6   ........           CALL    memcpy
   \   000000BA   ....               LDI     R18, LOW(sendbuf)
   \   000000BC   ....               LDI     R19, (sendbuf) >> 8
   \   000000BE   E602               LDI     R16, 98
   \   000000C0   E010               LDI     R17, 0
   \   000000C2   ....               RCALL   inisendfrm
   \   000000C4   C0B2               RJMP    ??req0handle_11
   \                     ??req0handle_4:
   \   000000C6   E000               LDI     R16, 0
   \   000000C8   ....               RCALL   sendack
   \   000000CA   ....               LDI     R16, LOW(rec0ctx)
   \   000000CC   ....               LDI     R17, (rec0ctx) >> 8
   \   000000CE   ........           CALL    inirec
   \   000000D2   95A8               WDR
   \   000000D4   E445               LDI     R20, 69
   \   000000D6   E050               LDI     R21, 0
   \   000000D8   ....               LDI     R18, LOW((rec0ctx + 7))
   \   000000DA   ....               LDI     R19, HIGH((rec0ctx + 7))
   \   000000DC   ....               LDI     R16, LOW(profile)
   \   000000DE   ....               LDI     R17, (profile) >> 8
   \   000000E0   ........           CALL    memcpy
   \   000000E4   ....               RCALL   wr_settings
   \   000000E6   9100....           LDS     R16, work_mode
   \   000000EA   300A               CPI     R16, 10
   \   000000EC   F019               BREQ    ??req0handle_12
   \   000000EE   ........           CALL    ini_activation
   \   000000F2   C09F               RJMP    ??req0handle_0
   \                     ??req0handle_12:
   \   000000F4   ........           CALL    ini_workbyprofile
   \   000000F8   C09C               RJMP    ??req0handle_0
   \                     ??req0handle_5:
   \   000000FA   E000               LDI     R16, 0
   \   000000FC   ....               RCALL   sendack
   \   000000FE   ........           CALL    ini_activation
   \   00000102   C093               RJMP    ??req0handle_11
   \                     ??req0handle_6:
   \   00000104   E000               LDI     R16, 0
   \   00000106   ....               RCALL   sendack
   \   00000108   ........           CALL    ini_workbyprofile
   \   0000010C   E000               LDI     R16, 0
   \   0000010E   9300....           STS     stepcnt, R16
   \   00000112   C08B               RJMP    ??req0handle_11
   \                     ??req0handle_7:
   \   00000114   E000               LDI     R16, 0
   \   00000116   ....               RCALL   sendack
   \   00000118   E000               LDI     R16, 0
   \   0000011A   9300....           STS     frmcnt, R16
   \   0000011E   C085               RJMP    ??req0handle_11
   \                     ??req0handle_8:
   \   00000120   ....               LDI     R30, LOW(senlen)
   \   00000122   ....               LDI     R31, (senlen) >> 8
   \   00000124   8100               LD      R16, Z
   \   00000126   8111               LDD     R17, Z+1
   \   00000128   2B01               OR      R16, R17
   \   0000012A   F081               BREQ    ??req0handle_13
   \   0000012C   9100....           LDS     R16, frmcnt
   \   00000130   9110....           LDS     R17, (rec0ctx + 7)
   \   00000134   1701               CP      R16, R17
   \   00000136   F451               BRNE    ??req0handle_13
   \   00000138   ....               LDI     R30, LOW(forsend)
   \   0000013A   ....               LDI     R31, (forsend) >> 8
   \   0000013C   8120               LD      R18, Z
   \   0000013E   8131               LDD     R19, Z+1
   \   00000140   ....               LDI     R30, LOW(senlen)
   \   00000142   ....               LDI     R31, (senlen) >> 8
   \   00000144   8100               LD      R16, Z
   \   00000146   8111               LDD     R17, Z+1
   \   00000148   ....               RCALL   inisendfrm
   \   0000014A   C06F               RJMP    ??req0handle_11
   \                     ??req0handle_13:
   \   0000014C   9100....           LDS     R16, (rec0ctx + 7)
   \   00000150   9300....           STS     frmcnt, R16
   \   00000154   ....               LDI     R30, LOW(forsend)
   \   00000156   ....               LDI     R31, (forsend) >> 8
   \   00000158   8120               LD      R18, Z
   \   0000015A   8131               LDD     R19, Z+1
   \   0000015C   ....               LDI     R16, LOW(prbuf0)
   \   0000015E   ....               LDI     R17, (prbuf0) >> 8
   \   00000160   1720               CP      R18, R16
   \   00000162   0731               CPC     R19, R17
   \   00000164   F4E1               BRNE    ??req0handle_14
   \   00000166   ....               LDI     R16, LOW(prbuf1)
   \   00000168   ....               LDI     R17, (prbuf1) >> 8
   \   0000016A   ....               LDI     R30, LOW(forsend)
   \   0000016C   ....               LDI     R31, (forsend) >> 8
   \   0000016E   8300               ST      Z, R16
   \   00000170   8311               STD     Z+1, R17
   \   00000172   ....               LDI     R16, LOW(prbuf0)
   \   00000174   ....               LDI     R17, (prbuf0) >> 8
   \   00000176   ....               LDI     R30, LOW(curbuf)
   \   00000178   ....               LDI     R31, (curbuf) >> 8
   \   0000017A   8300               ST      Z, R16
   \   0000017C   8311               STD     Z+1, R17
   \   0000017E   ....               LDI     R30, LOW(curoffset)
   \   00000180   ....               LDI     R31, (curoffset) >> 8
   \   00000182   8180               LD      R24, Z
   \   00000184   8191               LDD     R25, Z+1
   \   00000186   9601               ADIW    R25:R24, 1
   \   00000188   ....               LDI     R30, LOW(senlen)
   \   0000018A   ....               LDI     R31, (senlen) >> 8
   \   0000018C   8380               ST      Z, R24
   \   0000018E   8391               STD     Z+1, R25
   \   00000190   E007               LDI     R16, 7
   \   00000192   E010               LDI     R17, 0
   \   00000194   ....               LDI     R30, LOW(curoffset)
   \   00000196   ....               LDI     R31, (curoffset) >> 8
   \   00000198   8300               ST      Z, R16
   \   0000019A   8311               STD     Z+1, R17
   \   0000019C   C01B               RJMP    ??req0handle_15
   \                     ??req0handle_14:
   \   0000019E   ....               LDI     R16, LOW(prbuf0)
   \   000001A0   ....               LDI     R17, (prbuf0) >> 8
   \   000001A2   ....               LDI     R30, LOW(forsend)
   \   000001A4   ....               LDI     R31, (forsend) >> 8
   \   000001A6   8300               ST      Z, R16
   \   000001A8   8311               STD     Z+1, R17
   \   000001AA   ....               LDI     R16, LOW(prbuf1)
   \   000001AC   ....               LDI     R17, (prbuf1) >> 8
   \   000001AE   ....               LDI     R30, LOW(curbuf)
   \   000001B0   ....               LDI     R31, (curbuf) >> 8
   \   000001B2   8300               ST      Z, R16
   \   000001B4   8311               STD     Z+1, R17
   \   000001B6   ....               LDI     R30, LOW(curoffset)
   \   000001B8   ....               LDI     R31, (curoffset) >> 8
   \   000001BA   8180               LD      R24, Z
   \   000001BC   8191               LDD     R25, Z+1
   \   000001BE   9601               ADIW    R25:R24, 1
   \   000001C0   ....               LDI     R30, LOW(senlen)
   \   000001C2   ....               LDI     R31, (senlen) >> 8
   \   000001C4   8380               ST      Z, R24
   \   000001C6   8391               STD     Z+1, R25
   \   000001C8   E007               LDI     R16, 7
   \   000001CA   E010               LDI     R17, 0
   \   000001CC   ....               LDI     R30, LOW(curoffset)
   \   000001CE   ....               LDI     R31, (curoffset) >> 8
   \   000001D0   8300               ST      Z, R16
   \   000001D2   8311               STD     Z+1, R17
   \                     ??req0handle_15:
   \   000001D4   E000               LDI     R16, 0
   \   000001D6   ....               LDI     R26, LOW(curbuf)
   \   000001D8   ....               LDI     R27, (curbuf) >> 8
   \   000001DA   91ED               LD      R30, X+
   \   000001DC   91FC               LD      R31, X
   \   000001DE   9711               SBIW    R27:R26, 1
   \   000001E0   8306               STD     Z+6, R16
   \   000001E2   E809               LDI     R16, 137
   \   000001E4   ....               LDI     R26, LOW(forsend)
   \   000001E6   ....               LDI     R27, (forsend) >> 8
   \   000001E8   91ED               LD      R30, X+
   \   000001EA   91FC               LD      R31, X
   \   000001EC   9711               SBIW    R27:R26, 1
   \   000001EE   8303               STD     Z+3, R16
   \   000001F0   9100....           LDS     R16, frmcnt
   \   000001F4   ....               LDI     R26, LOW(forsend)
   \   000001F6   ....               LDI     R27, (forsend) >> 8
   \   000001F8   91ED               LD      R30, X+
   \   000001FA   91FC               LD      R31, X
   \   000001FC   9711               SBIW    R27:R26, 1
   \   000001FE   8305               STD     Z+5, R16
   \   00000200   ....               LDI     R30, LOW(forsend)
   \   00000202   ....               LDI     R31, (forsend) >> 8
   \   00000204   8120               LD      R18, Z
   \   00000206   8131               LDD     R19, Z+1
   \   00000208   ....               LDI     R30, LOW(senlen)
   \   0000020A   ....               LDI     R31, (senlen) >> 8
   \   0000020C   8100               LD      R16, Z
   \   0000020E   8111               LDD     R17, Z+1
   \   00000210   ....               RCALL   inisendfrm
   \   00000212   C00B               RJMP    ??req0handle_11
   \                     ??req0handle_9:
   \   00000214   E000               LDI     R16, 0
   \   00000216   ....               RCALL   sendack
   \   00000218   ....               LDI     R16, LOW(rec0ctx)
   \   0000021A   ....               LDI     R17, (rec0ctx) >> 8
   \   0000021C   ........           CALL    inirec
   \   00000220   95A8               WDR
   \   00000222   ........           CALL    calibration
   \   00000226   C005               RJMP    ??req0handle_0
   \                     ??req0handle_10:
   \   00000228   ....               RCALL   sendexept
   \                     ??req0handle_11:
   \   0000022A   ....               LDI     R16, LOW(rec0ctx)
   \   0000022C   ....               LDI     R17, (rec0ctx) >> 8
   \   0000022E   ........           CALL    inirec
   \                     ??req0handle_0:
   \   00000232   E0E4               LDI     R30, 4
   \   00000234   ........           JMP     ?EPILOGUE_B4_L09
   \   00000238                      REQUIRE _A_UCSR0B
    590             
    591             
    592          }
    593          };

   \                                 In  segment INTVEC, offset 0x48, root
   \                     `??rx0_isr??INTVEC 72`:
   \   00000048   ........           JMP     rx0_isr

   \                                 In  segment INTVEC, offset 0x4c, root
   \                     `??tx0_isr??INTVEC 76`:
   \   0000004C   ........           JMP     tx0_isr

   \                                 In  segment INTVEC, offset 0x50, root
   \                     `??tx0end_isr??INTVEC 80`:
   \   00000050   ........           JMP     tx0end_isr

   \                                 In  segment NEAR_ID, align 1, keep-with-next
   \                     `?<Initializer for adr>`:
   \   00000000   02                 DB 2

   \                                 In  segment SWITCH, align 2, keep-with-next
   \                     `?<Jumptable for iniuart0>_0`:
   \   00000000   3000               DW      12288
   \   00000002   01                 DB      1
   \   00000003   ....               DW      (??iniuart0_11) /2
   \   00000005   ....               DW      (??iniuart0_4) /2
   \   00000007   30                 DB      0x30
   \   00000008   ....               DW      (??iniuart0_6) /2
   \   0000000A   60                 DB      0x60
   \   0000000B   ....               DW      (??iniuart0_7) /2
   \   0000000D   C0                 DB      0xc0
   \   0000000E   ....               DW      (??iniuart0_8) /2
   \   00000010   C0                 DB      0xc0
   \   00000011   ....               DW      (??iniuart0_9) /2
   \   00000013   02FE40             DB      254,0x2,0x40
   \   00000016   ....               DW      (??iniuart0_10) /2
   \   00000018   FB                 DB      251
   \   00000019   00                 DB      0
    594          

   Maximum stack usage in bytes:

     Function               CSTACK RSTACK
     --------               ------ ------
     _copy                      0      2
     chkfrm                     4      2
       -> getcrc                4      2
     inisendfrm                 6      2
       -> getcrc                6      2
       -> inisend               6      2
       -> inirec                6      2
     iniuart0                   4      2
       -> inirec                4      2
     read_settings              0      4
     req0handle                 4      2
       -> chkfrm                4      2
       -> inirec                4      2
       -> memcpy                4      2
       -> inisendfrm            4      2
       -> memcpy                4      2
       -> inisendfrm            4      2
       -> sendack               4      2
       -> inirec                4      2
       -> memcpy                4      2
       -> wr_settings           4      2
       -> ini_activation        4      2
       -> ini_workbyprofile     4      2
       -> sendack               4      2
       -> ini_activation        4      2
       -> sendack               4      2
       -> ini_workbyprofile     4      2
       -> sendack               4      2
       -> inisendfrm            4      2
       -> inisendfrm            4      2
       -> sendack               4      2
       -> inirec                4      2
       -> calibration           4      2
       -> sendexept             4      2
       -> inirec                4      2
     rx0_isr                   17      2
       -> recnextch            17      2
     sendack                    1      2
       -> inisendfrm            1      2
     sendexept                  4      2
       -> _copy                 4      2
       -> getcrc                4      2
       -> inisend               4      2
     setch                      0      4
     setrg                      4      2
       -> setch                 4      2
       -> setch                 4      2
     tx0_isr                   17      2
       -> getnextch            17      2
       -> addh                 17      2
       -> addh                 17      2
     tx0end_isr                16      2
       -> inirec               16      2
     wr_settings                4      2
       -> setch                 4      2


   Segment part sizes:

     Function/Label              Bytes
     --------------              -----
     _A_UBRR0L                      1
     _A_UCSR0B                      1
     _A_UCSR0A                      1
     _A_UDR0                        1
     _A_EECR                        1
     _A_EEDR                        1
     _A_EEAR                        2
     _A_OCR1A                       2
     _A_TCNT1                       2
     _A_TIFR                        1
     _A_UBRR0H                      1
     _A_UCSR0C                      1
     _A_UCSR1B                      1
     frmcnt                         1
     forsend                        2
     work_mode                      1
     adr                            1
     rec0ctx                      515
     iniuart0                     212
     tx0end_isr                    98
     rx0_isr                      128
     sen0ctx                        5
     tx0_isr                      136
     chkfrm                       106
     sbuf                        1026
     ??_copy_0                     30
     sendexept                    178
     inisendfrm                   104
     sendbuf                      200
     prbufcur                       1
     curoffset                      2
     curbuf                         2
     prbuf0                       900
     prbuf1                       900
     offset1                        2
     offset2                        2
     profile                       69
     setch                         36
     read_settings                158
     wr_settings                   46
     setrg                         50
     oldportg                       1
     need_portgsel                  1
     sendack                       32
     senlen                         2
     req0handle                   568
     ??rx0_isr??INTVEC 72           4
     ??tx0_isr??INTVEC 76           4
     ??tx0end_isr??INTVEC 80        4
     ?<Initializer for adr>         1
     ?<Jumptable for iniuart0>_0   26
      Others                       14

 
    16 bytes in segment ABSOLUTE
 1 882 bytes in segment CODE
    14 bytes in segment INITTAB
    12 bytes in segment INTVEC
     1 byte  in segment NEAR_I
     1 byte  in segment NEAR_ID
 3 632 bytes in segment NEAR_Z
    26 bytes in segment SWITCH
 
 1 909 bytes of CODE memory (+ 26 bytes shared)
 3 633 bytes of DATA memory (+ 16 bytes shared)

Errors: none
Warnings: 2
