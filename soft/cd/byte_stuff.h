#ifndef byte_stuff_h
#define byte_stuff_h
/* модуль отработки автомата байт-стаффинга на прием и передачу */
#include "hwr.h"
typedef struct  {
  int lrec;
  char recst;
  unsigned char rbuf[rbuf_size];
}trecctx;
typedef struct  {
  int l;
  char * senptr;
  char senst;
}tsenctx;
typedef struct  {
  int all,sync,lenmin,lenmax,crc,len;
}terrstat;


void inisend(int l, char * bufpoint,tsenctx * senctx);
/* инициализация автомата передачи.
    l- длина передаваемого кадра
    bufpoint - указательна сам передаваемый кадр
    senctx - контекст автомата ( необходимо передавать эту структуру
              далее постоянно при вызовах getnextch )

    при этом для запуска самой передачи
в функции вызывается макрос send_begin, который должен быть определен заранее,
в файле hwr.h
*/

char getnextch(char *nextch, tsenctx * senctx);
/* передающий автомат
функция обычно используется при вызове на уровне прерываения передатчика от UART.
nextch - переменная в которой возвращается следующий байт для передачи
функция возвращает 0, если есть байт на передачу и 1 - если все уже
передано */

void inirec(trecctx * recctx);
/* функция инициирует автомат приема,
recctx - структура содержащая буфер приема, длину переданного кадра и др.
          служебные поля ( необходимо передавать эту структуру
          далее постоянно при вызовах recfrm )
*/

//char recfrm(char nextch);
char recnextch(char nextch,trecctx * recctx);
/* функция автомата приема по байтстаффингу (для корректной работы в файле
hwr.h должна быть определена константа rbuf_size - размер буфера приема.)
возвращает 0- принят очередной кадр
           1- идет прием кадра
           2 - был сбой, ожидаем синхронизации.
В случае успешного приема кадра   в глобальной переменной lrec возвращается
длинна принятого кадра. Сам кадр находится в массиве rbuf.
последующий вызов recfrm приведет к тоиу, что будет производится прием сле-
дующего кадра и значения lrec и rbuf станут неопределены. */

int makefrm(char * outbuff,char * frm, int len, int maxlen);

/* формирования уже готового передаче кадра со сформированным байт стаффингом
   ( это комбинация inisend и getnextch, функция хороша при работе под виндами,
   когда последовательный порт - это устройство и лучше весь кадр выдать целиком).
   outbuff - указатель на буфер где будет сформирован выходной кадр
   frm - кадр на передачу ( еще без байт-стаффинга)
   len - длина кадра на передачу.
   maxlen - длина выходного буфера, которую нельзя превысить.
   Внимание!!! размер выходного буфера может теоретически достичь значения
        входной буфер*2 + 4 !!!!  Резервируйте место!!!!!!!

*/

int recfrm_bs(trecctx * recctx, char *source, int len,int *curroffs);
/* откработка автомата байт-стаффинга на приеме
   возвращает 0 - кадр принят
              1 - кадр не принят
   кроме этого заполняет структуру подсчета статистики ошибок
   recctx - структура для принятого кадра
   source - принятая из com порта последовательность байт
   len - количество принятых байт
*/
void inierrorstat();//обнуление статистики ошибок
void seterrorcrc();//добавление ошибки СRC.
void seterrorlen();//добавление ошибки не сошлась длина.
#endif
